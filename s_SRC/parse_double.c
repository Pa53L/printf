#include "../h_HEAD/header.h"

<<<<<<< HEAD
char DEG_ARR[64][65] =
 {  "1000000000000000000000000000000000000000000000000000000000000000",   // 0
    "0500000000000000000000000000000000000000000000000000000000000000",   // 1
    "0250000000000000000000000000000000000000000000000000000000000000",   // 2
    "0125000000000000000000000000000000000000000000000000000000000000",   // 3
    "0062500000000000000000000000000000000000000000000000000000000000",   // 4
    "0031250000000000000000000000000000000000000000000000000000000000",   // 5
    "0015625000000000000000000000000000000000000000000000000000000000",   // 6
    "0007812500000000000000000000000000000000000000000000000000000000",   // 7
    "0003906250000000000000000000000000000000000000000000000000000000",   // 8
    "0001953125000000000000000000000000000000000000000000000000000000",   // 9
    "0000976562500000000000000000000000000000000000000000000000000000",   // 10
    "0000488281250000000000000000000000000000000000000000000000000000",   // 11
    "0000244140625000000000000000000000000000000000000000000000000000",   // 12
    "0000122070312500000000000000000000000000000000000000000000000000",   // 13
    "0000061035156250000000000000000000000000000000000000000000000000",   // 14
    "0000030517578125000000000000000000000000000000000000000000000000",   // 15
    "0000015258789062500000000000000000000000000000000000000000000000",   // 16
    "0000007629394531250000000000000000000000000000000000000000000000",   // 17
    "0000003814697265625000000000000000000000000000000000000000000000",   // 18
    "0000001907348632812500000000000000000000000000000000000000000000",   // 19
    "0000000953674316406250000000000000000000000000000000000000000000",   // 20
    "0000000476837158203125000000000000000000000000000000000000000000",   // 21
    "0000000238418579101562500000000000000000000000000000000000000000",   // 22
    "0000000119209289550781250000000000000000000000000000000000000000",   // 23
    "0000000059604644775390625000000000000000000000000000000000000000",   // 24
    "0000000029802322387695312500000000000000000000000000000000000000",   // 25
    "0000000014901161193847656250000000000000000000000000000000000000",   // 26
    "0000000007450580596923828125000000000000000000000000000000000000",   // 27
    "0000000003725290298461914062500000000000000000000000000000000000",   // 28
    "0000000001862645149230957031250000000000000000000000000000000000",   // 29
    "0000000000931322574615478515625000000000000000000000000000000000",   // 30
    "0000000000465661287307739257812500000000000000000000000000000000",   // 31
    "0000000000232830643653869628906250000000000000000000000000000000",   // 32
    "0000000000116415321826934814453125000000000000000000000000000000",   // 33
    "0000000000058207660913467407226562500000000000000000000000000000",   // 34
    "0000000000029103830456733703613281250000000000000000000000000000",   // 35
    "0000000000014551915228366851806640625000000000000000000000000000",   // 36
    "0000000000007275957614183425903320312500000000000000000000000000",   // 37
    "0000000000003637978807091712951660156250000000000000000000000000",   // 38
    "0000000000001818989403545856475830078125000000000000000000000000",   // 39
    "0000000000000909494701772928237915039062500000000000000000000000",   // 40
    "0000000000000454747350886464118957519531250000000000000000000000",   // 41
    "0000000000000227373675443232059478759765625000000000000000000000",   // 42
    "0000000000000113686837721616029739379882812500000000000000000000",   // 43
    "0000000000000056843418860808014869689941406250000000000000000000",   // 44
    "0000000000000028421709430404007434844970703125000000000000000000",   // 45
    "0000000000000014210854715202003717422485351562500000000000000000",   // 46
    "0000000000000007105427357601001858711242675781250000000000000000",   // 47
    "0000000000000003552713678800500929355621337890625000000000000000",   // 48
    "0000000000000001776356839400250464677810668945312500000000000000",   // 49
    "0000000000000000888178419700125232338905334472656250000000000000",   // 50
    "0000000000000000444089209850062616169452667236328125000000000000",   // 51
    "0000000000000000222044604925031308084726333618164062500000000000",   // 52
    "0000000000000000111022302462515654042363166809082031250000000000",   // 53
    "0000000000000000055511151231257827021181583404541015625000000000",   // 54
    "0000000000000000027755575615628913510590791702270507812500000000",   // 55
    "0000000000000000013877787807814456755295395851135253906250000000",   // 56
    "0000000000000000006938893903907228377647697925567626953125000000",   // 57
    "0000000000000000003469446951953614188823848962783813476562500000",   // 58
    "0000000000000000001734723475976807094411924481391906738281250000",   // 59
    "0000000000000000000867361737988403547205962240695953369140625000",   // 60
    "0000000000000000000433680868994201773602981120347976684570312500",   // 61
    "0000000000000000000216840434497100886801490560173988342285156250",   // 62
    "0000000000000000000108420217248550443400745280086994171142578125" }; // 63

=======
>>>>>>> bb0213eb14a607ec313ea3c8a08a214c88be869d
char    *parse_double(long double number, int pres)
{
    ld_cast d1 = { .ld = number };
    char *str_right;
    char *str_left;
    char *full_str;
    
    // КУСОК ПАРСА МАНТИССЫ
    str_right = (char *)malloc(sizeof(char) * 65);
    str_right = parse_mantis(d1.parts.mantisa);
    // КУСОК ПАРСА ЭКСПОНЕНТЫ
    str_left = (char *)malloc(sizeof(char) * 5000);
    str_left = parse_exponent(d1.parts.exponent);
<<<<<<< HEAD
    
=======
>>>>>>> bb0213eb14a607ec313ea3c8a08a214c88be869d
    // СОБИРАЕМ ПОЛНУЮ СТРОКУ
    full_str = (char *)malloc(sizeof(char) * 5000);
    int len1 = ft_strlen(str_left) - 1;
    int len2 = ft_strlen(str_right) - 1;
    int k = 0;
    while (k < (len1 + len2))
    {
        full_str[k] = '0';
        k++;
    }
<<<<<<< HEAD

    len1 < len2 ? (full_str = ft_str_multiply(str_left, str_right, len1, len2, full_str)) : (full_str = ft_str_multiply(str_right, str_left, len2, len1, full_str));
    full_str[len1 + len2 - 1] = '\0';

=======
    
    len1 < len2 ? (full_str = ft_str_multiply(str_left, str_right, len1, len2, full_str)) : (full_str = ft_str_multiply(str_right, str_left, len2, len1, full_str));
    full_str[len1 + len2 - 1] = '\0';
    
>>>>>>> bb0213eb14a607ec313ea3c8a08a214c88be869d
    // ПОРА ПЕРЕПИСАТЬ ЭТОТ КУСОК
    //printf("%s\n", full_str);
    if (number > 1 || number < -1)
        full_str = make_dot(full_str, d1.parts.exponent);
    else
        full_str = make_dot_zero(full_str, d1.parts.exponent);
    //printf("%s\n", full_str);
    full_str = make_rounding(full_str, pres);
    //printf("PORNONAL %s\n", full_str);
    return (full_str);
}
// ОКРУГЛЯЕМ ДО ЗАДАННОГО ЗНАЧЕНИЯ
char    *make_rounding(char *str, int pres)
{
    char *tmp;
    if (!(tmp = (char *)malloc(sizeof(char) * (ft_strlen(str) + pres + 1))))
        return (NULL);
    int i; // Считаем до точки и после точки
    int j;
    int mem;
    
    j = 0;
    i = 0;
    while (str[i] != '.')
    {
        tmp[i] = str[i];
        i++;
    }
    tmp[i++] = '.';
    j = i;
    while (pres-- >= 0)
    {
        while (str[j] != '\0' && pres-- >= 0)
            tmp[i++] = str[j++];
        tmp[i++] = '0';
    }

    i--;
    (str[i] >= '5' ? (mem = 1) : (mem = 0));
    tmp[i] = '\0';
    tmp = ft_rounding(tmp, mem);

    return (tmp);
}

// НАКОНЕЦ ОКРУГЛЯЕМ ДО КОНЦА
char    *ft_rounding(char *str, int mem)
{
    int i;
    i = ft_strlen(str) - 1;
    while (i >= 0)
    {
        if (str[i] == '.')
            i--;
        if (mem == 1 && str[i] >= '0' && str[i] < '9')
        {
            str[i] = ((str[i] - '0') + mem) + '0';
            mem = 0;
            break ;
        }
        else if (mem == 1 && str[i] == '9')
        {
            str[i] = '0';
            i--;
        }
        else
            break ;
    }
    if (i == -1 && mem == 1)
        str = ft_strjoin("1", str);
    return (str);
}
// СТАВИТ ТОЧКУ В ЧИСЛЕ. ВРОДЕ НОРМ. ПОКА НЕ ТРОГАТЬ
char    *make_dot(char *str, unsigned short exponent)
{
    int i;
    int j;
    char *tmp;

    i = 0;
    j = 0;
    if (!(tmp = (char *)malloc(sizeof(char) * (ft_strlen(str) + 1))))
        return (NULL);
    tmp[ft_strlen(str)] = '\0';
    if (str[i] == '0')
        i++;
    while (i <= ((exponent - 16383) * 0.301 + 1))
        tmp[j++] = str[i++];
    tmp[j] = '.';
    j++;
    while (str[i] != '\0')
        tmp[j++] = str[i++];

    return (tmp);
}

char    *make_dot_zero(char *str, unsigned short exponent)
{
    int i;
    int j;
    char *tmp;

    i = 2;
    j = 2;
    if (!(tmp = (char *)malloc(sizeof(char) * (ft_strlen(str) + 2))))
        return (NULL);
    tmp[ft_strlen(str)] = '\0';
    tmp[0] = '0';
    tmp[1] = '.';
    while (str[i] != '\0')
    {
        tmp[j] = str[i];
        i++;
        j++;
    }

    return (tmp);    
}
// Парсим экспоненту в строку
char    *parse_exponent(unsigned short exponent)
{
    int pow;
    char *str;
    
    pow = exponent - 16383;
    if (pow > 0)
    {
        str = (char *)malloc(sizeof(char) * (pow * 0.301 + 1));
        str = ft_pow(str, pow);
    }
    else if (pow == 0)
    {
        return ("1");
    }
    else
    {
        pow = pow * -1;
        str = (char *)malloc(sizeof(char) * (pow + 1));
        str = ft_pow5(str, pow);
    }

    return (str);
}

// Начинаем парсить МАНТИССУ в строку
char    *parse_mantis(unsigned long mantisa)
{
    // мантисса в виде степеней -2 в нужных местах (массив строк)
    char *str;
    
    str = (char *)malloc(sizeof(char) * 65);
    str[64] = '\0';
    int j = 0;
    while (j <= 63)
    {
        str[j] = '0';
        j++;
    }
    str = make_mantisa(str, mantisa);
    return(str);
    
}

// Собирает МАНТИССУ из индексов массива
char *make_mantisa(char *str, unsigned long mantisa)
{
    char bin_str[8 * sizeof(unsigned long) + 1];
    int i;
    int j;
    int mem;
    char tmp;
    
    mem = 0;
    i = 0;
    // printf("%s\n", itobs(mantisa, bin_str));
    while (itobs(mantisa, bin_str)[i] != '\0')
    {
        j = 63;
        if (itobs(mantisa, bin_str)[i] == '1')
        {
            while (j >= 0)
            {
                tmp = str[j];
                str[j] = ((str[j] - '0') + (DEG_ARR[i][j] - '0') + mem) % 10 + '0';
                mem = ((tmp - '0') + (DEG_ARR[i][j] - '0') + mem) / 10;
                j--;
            }
        }
        i++;
    }

    return (str);
}

// Мантиссу в строку битов
char *itobs(unsigned long long n, char *ps)
{
    int i;
    uint64_t size = 8 * sizeof(uint64_t);
    
    i = size - 1;
    while (i >= 0)
    {
        ps[i] = (01 & n) + '0';
        i--;
        n >>= 1;
    }
    ps[size] = '\0';

    return (ps);
}

char *ft_str_multiply(char *str1, char *str2, int len1, int len2, char *tmp)
{
    int i;
    int j;
    int shift;  // Поразрядный сдвиг
    int mem;    // Число "в уме"
    int res;
    
    shift = 0;
    i = len2;
    while (i >= 0)
    {
        j = len1;
        mem = 0;
        while (j >= 0)
        {
            res = (str1[j] - '0') * (str2[i] - '0') + (tmp[j + len2 + 1 - shift] - '0') + mem;
            mem = res / 10;
            tmp[j + len2 + 1 - shift] = res % 10 + '0';
            if (j == 0)
                tmp[i] = mem + '0';
            j--;
        }
        shift++;
        i--;
    }
    //tmp[len1 + len2 - 3] = '\0';

    return (tmp);
}

char *ft_pow(char *res, int pow)
{
    int len;
    int ret;
    int dec;

    len = pow * 0.301 + 1;
    ret = 0;
    res[len] = '\0';
    res[len - 1] = '2';
    int j = -1;
    while (j++ < (len - 2))
        res[j] = '0';
    while (pow > 1)
    {
        len = ft_strlen(res) - 1;
        while (len >= 0)
        {
            dec = res[len] - '0';
            res[len] = (dec * 2 + ret) % 10 + '0';
            ret = (dec * 2 + ret) < 10 ? 0 : 1;
            len--;
        }
        res[len] = ret + '0';
        pow--;
    }
    return (res);
}

char *ft_pow5(char *res, int pow)
{
    int len;
    int ret;
    int dec;

    len = pow + 1;
    ret = 0;
    res[len] = '\0';
    res[len - 1] = '5';
    int j = -1;
    while (j++ < (len - 2))
        res[j] = '0';
    while (pow > 1)
    {
        len = ft_strlen(res) - 1;
        while (len >= 0)
        {
            dec = res[len] - '0';
            res[len] = (dec * 5 + ret) % 10 + '0';
            ret = (dec * 5 + ret) < 10 ? 0 : ((dec * 5 + ret) / 10);
            len--;
        }
        res[len] = ret + '0';
        pow--;
    }
    return (res);
}
